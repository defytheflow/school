#!/bin/bash

usage()
{
    echo -e "Generates a default directory structure for a lesson.\n"
    echo "Usage:"
    echo -e "  lesson [options] <command>\n"
    echo "Arguments:"
    echo "  command                      name of the command"
    echo "  lesson_num                   the lesson number"
    echo ""
    echo "Options:"
    echo "  -f, --force                  disable warnings"
    echo "  -h, --help                   displays a usage message"
    echo "  -m <lang>, --make <lang>     creates a makefile inside of each directory"
    echo ""
    echo "Commands:"
    echo "  begin, start <lesson_num>    creates the directories for the lesson."
    echo "  begin-next, start-next       same as begin, but automatically decides"
    echo "                               <lesson_num>."
    echo "  end, finish  <lesson_num>    removes unused directories for the lesson."
    echo "  end-last, finish-last        same as end, but automatically decides"
    echo "                               <lesson_num>."
    echo "  help                         displays a help message."
    echo ""
    echo "Examples:"
    echo "  lesson begin 1"
    echo "  lesson begin-next"
    echo "  lesson end 1"
    echo "  lesson end-last"
    echo ""
    echo "Author:"
    echo -e "  Artyom Daniov\n"
}

## GLOBAL VARIABLES

declare -A FLAGS=(

    [force]=0  # -f, --force
    [make]=""  # -m, --make

)

declare -A COMMANDS=(

    [begin]=0  # begin
    [begin-next]=0
    [end]=0    # end
    [end-next]=0

)

MAX_LESSON_NUM=100
LESSONS_DIR="Lessons"
LESSON_DIRECTORIES=(Examples Exercises Theory Whiteboard Programs
                    Homework Todo Ideas Modules Classes)

HELP_MESSAGE="Try: 'lesson -h | --help' for more information"
MAKEFILE="Makefile"
MIN_COMMIT_MESSAGE_LENGTH=20

## FUNCTION DEFINITIONS

# Returns 0 if $1 is a script command
is_command()
{
    for com in "${!COMMANDS[@]}"; do
        if [[ "$com" == "$1" ]]; then
            return 0
        fi
    done
    return 1
}

# Returns 0 if $1 has a '.something' at the end
has_ext()
{
    if [[ "$1" =~ ^.+\..+$ ]]; then
        return 0
    else
        return 1
    fi
}

## PARSE OPTIONS

short_options="fhm:"
long_options="force,help,make:"

options=$(getopt -o $short_options -l $long_options -- "$@")

if [[ $? -ne 0 ]]; then
    echoerr $HELP_MESSAGE
    exit 1
fi

eval set -- "$options"  # sets $options as script arguments

## SET OPTIONS

while true; do
    case $1 in
        -f | --force)
            FLAGS[force]=1
            ;;
        -h | --help)
            usage
            exit 0
            ;;
        -m | --make)
            shift
            if [[ $1 == "c" || $1 == "cpp" ]]; then
                FLAGS[make]=$1
            elif is_command $1; then
                echoerr "Error: '-m, --make' option requires an argument."
                echoerr $HELP_MESSAGE
                exit 1
            else
                echoerr "Error: '$1' makefile is not supported."
                echoerr "Supported makefiles: c, cpp"
                echoerr $HELP_MESSAGE
                exit 1
            fi
            ;;
        --)
            shift
            break
            ;;
    esac
    shift
done

## VALIDATION

# Check the <command> is given
if [[ $# -lt 1 ]]; then
    echoerr "Error: missing <command> argument"
    echoerr $HELP_MESSAGE
    exit 1
fi

## SET COMMAND

# Check the <command> argument is valid

command=$1
shift

case $command in
    begin | start)
        if [[ $# -lt 1 ]]; then
            echoerr "Error: '$command' missing <lesson_num> argument"
            echoerr $HELP_MESSAGE
            exit 1
        fi
        FLAGS[begin]=1 ;;
    begin-next | start-next)
        FLAGS[begin-next]=1
        ;;
    end | finish)
        if [[ $# -lt 1 ]]; then
            echoerr "Error: '$command' missing <lesson_num> argument"
            echoerr $HELP_MESSAGE
            exit 1
        fi
        FLAGS[end]=1 ;;
    end-last | finish-last)
        FLAGS[end-last]=1
        ;;
    help)
        usage
        exit 0 ;;
    *)
        echoerr "Error: unknown command '$1'"
        echoerr $HELP_MESSAGE
        exit 1 ;;
esac

# Check if inside of LESSONS_DIR directory
if [[ ! "$(pwd)" =~ .+/$LESSONS_DIR$ ]]; then
    if [[ ${FLAGS[force]} -ne 1 ]]; then
        echo "Not inside '$LESSONS_DIR' directory"
        echo "It may affect how I work"
        read -p "Proceed? [y/n]: " ans
        [[ ! "$ans" =~ ^[yY]$ ]] && exit 0
    fi
fi

## SET LESSON_NUM

if [[ ${FLAGS[begin-next]} -eq 1 ]]; then

    # find the largest lesson and add + 1
    LESSON_NUM=$(ls | grep -E '[0-9]+' | sort -n | tail -1)
    LESSON_NUM=$(( LESSON_NUM + 1 ))
    FLAGS[begin]=1

elif [[ ${FLAGS[end-last]} -eq 1 ]]; then
    # find the largest lesson
    LESSON_NUM=$(ls |  grep -E '[0-9]+' | sort -n | tail -1)
    FLAGS[end]=1

else
    # remove parent directory names
    LESSON_NUM=${1##*/}
fi

shift

## VALIDATION

# Check if <lesson_num> argument is a positive number
if ! isuint $LESSON_NUM; then
    echoerr "Error: <lesson_num> argument must be an integer"
    echoerr "Fix: Try 1..$MAX_LESSON_NUM"
    exit 1
fi

# Check if <lesson_num> argument is less than or equal MAX_LESSON_NUM
if [[ ! "$LESSON_NUM" -le $MAX_LESSON_NUM ]]; then
    if [[ ${FLAGS[force]} -ne 1 ]]; then
        echo "$LESSON_NUM exceeds the MAX_LESSON_NUM"
        read -p "Proceed? [y/n]: " ans
        [[ ! "$ans" =~ ^[yY]$ ]] && exit 0
    fi
fi

## MAIN JOB

if [[ ${FLAGS[begin]} -eq 1 ]]; then

    ## PRECAUTIONS

    # Check if there is a Lesson with number <lesson_num>
    if [[ -d $LESSON_NUM ]]; then
        echoerr "Error: Lesson number '$LESSON_NUM' already exists"
        echoerr "Fix: Try another number"
        exit 1
    fi

    ## CREATE DIRECTORIES

    for dir in ${LESSON_DIRECTORIES[@]}; do
        mkdir -p $LESSON_NUM/$dir
    done

    ## MAKEFILE

    # Check if $MAKEFILE_FLAG is on
    if [[ -n ${FLAGS[make]} ]]; then

        # Check that 'new' script is installed
        if [[ ! -x $(command -v new) ]]; then
            echoerr "Error: command not found 'new'"
            echoerr "Fix: run the 'install' script"
            exit 1
        fi

        # In each $dir create a Makefile
        for dir in ${LESSON_DIRECTORIES[@]}; do
            new --make=${FLAGS[make]} $LESSON_NUM/$dir/$MAKEFILE
        done
    fi

    # Create a time-stamp file
    touch $LESSON_NUM/.lesson_start

    ## BEGIN SCREEN

    columns=$(tput cols)
    printf "%0.s-" $(seq 1 $columns)
    echo ""
    echo ""
    echoc "Welcome to Lesson #$LESSON_NUM, $(whoami)!"
    echo ""
    echoc "Remember to express your ideas:"
    echo ""
    echoc " 1. Correctly"
    echo ""
    echoc " 2. Simply"
    echo ""
    echoc " 3. Efficiently"
    echo ""
    printf "%0.s-" $(seq 1 $columns)

elif [[ ${FLAGS[end]} -eq 1 ]]; then

    ## PRECAUTIONS

    # Check if there is no lesson with number <lesson_num>
    if [[ ! -d $LESSON_NUM ]]; then
        echoerr "Error: Lesson number '$LESSON_NUM' doesn't exist"
        exit 1
    fi

    ## FILE STATS

    style_errors=0
    exercises_completed=0
    programs_written=0

    ## FOR EACH DIRECTORY

    for dir in ${LESSON_DIRECTORIES[@]}; do

        full_dir="$LESSON_NUM/$dir"

        # if directory exists
        if [[ -d $full_dir ]]; then

            ## FOR EACH FILE INSIDE DIRECTORY

            for file in $(ls $full_dir); do

                full_file="$LESSON_NUM/$dir/$file"

                ## CHECK THAT FILE HAS EXTENSION

                # if file doesn't have an extension
                if ! has_ext $file && [[ $file != $MAKEFILE ]]; then
                    style_errors=$(( style_errors + 1 ))
                    echoerr "Style Error: '$full_file' doesn't have an extension."
                    echoerr "Fix: add an extension."
                fi

                ## CHECK THAT FILE IS NOT EMPTY

                if [[ ! -s $full_file ]]; then
                    style_errors=$(( style_errors + 1 ))
                    echoerr "Style Error: '$full_file' is empty."
                    echoerr "Fix: remove it."
                fi

                ## IF FILE IS AN EXERCISE OR A PROGRAM
                case $dir in
                    Exercises | Programs)
                    if [[ "$(file $full_file)" =~ "C source" ||
                          "$(file $full_file)" =~ "Python script" ]]; then
                        case $dir in
                            Exercises)
                            exercises_completed=$(( exercises_completed + 1 )) ;;
                            Programs)
                            programs_written=$(( programs_written + 1 )) ;;
                        esac
                    fi
                esac

            done

            ## REMOVE EMPTY DIRECTORIES

            # If directory is empty or only has a $MAKEFILE inside
            if isempty $full_dir ||
               [[ -f $full_dir/$MAKEFILE && $(filenum $full_dir) -eq 1 ]]; then
                rm -r $full_dir
            fi

        fi
    done

    # Exit if have 'style' errors
    [[ $style_errors -gt 0 ]] && exit 1

    ## TIME STATS

    if [[ -f $LESSON_NUM/.lesson_start ]]; then

        duration=$(( $(date +%s) - $(stat -c "%Y" $LESSON_NUM/.lesson_start) ))
        hours=$(( duration / 3600 ))
        minutes=$(( duration / 60 - hours * 60))
        seconds=$(( duration % 60 ))

        # Delete a time-stamp file
        rm $LESSON_NUM/.lesson_start

    fi

    ## GIT

    # If git repo and changes were made
    if [[ -d ".git" && -n $(git status --porcelain) ]]; then

        git status
        echo ""

        git add .

        # Tackle 'bad' commit messages
        while true; do
            read -ep "Enter commit message: " message

            if [[ ${#message} -lt $MIN_COMMIT_MESSAGE_LENGTH ]]; then
                echoerr "Error: commit message must be at least" \
                        "$MIN_COMMIT_MESSAGE_LENGTH characters long"
                continue
            fi

            break
        done

        echo ""
        git commit -m "$message"
        echo ""

        # Tackle wrong login/password issues
        while true; do
            git push
            [[ $? -eq 0 ]] && break
            echo ""
        done

    fi

    ## END SCREEN

    columns=$(tput cols)
    printf "%0.s-" $(seq 1 $columns)
    echo ""
    echoc "End of lesson #$LESSON_NUM. Goodbye, $(whoami)!"
    echo ""
    echoc "Stats:"
    echo ""
    echoc " 1. Lesson took $hours:$minutes:$seconds"
    echo ""
    echoc " 2. Exercises completed: $exercises_completed"
    echo ""
    echoc " 3. Programs written: $programs_written"
    echo ""

    # remove lesson dir if nothing has been created
    if isempty $LESSON_NUM; then
        rmdir $LESSON_NUM
    else
        tree $LESSON_NUM
    fi

    printf "%0.s-" $(seq 1 $columns)
fi

exit 0

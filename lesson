#!/bin/bash

usage()
{
    echo -e "Creates an environment for a coding lesson.\n"

    echo    "Usage:"
    echo -e "  lesson [options] <command>\n"

    echo    "Arguments:"
    echo    "  command                      name of the command."
    echo -e "  lesson_num                   the lesson number.\n"

    echo    "Options:"
    echo    "  -f, --force                  disable warnings."
    echo -e "  -h, --help                   display this message.\n"

    echo    "  -m <lang>, --make <lang>     create a makefile for a particular"
    echo -e "                               language inside of each directory.\n"

    echo    "Commands:"
    echo    "  start <lesson_num>           creates the directories and files"
    echo -e "                               for the lesson.\n"

    echo    "  start-next                   same as start, but automatically"
    echo -e "                               calculates <lesson_num>.\n"

    echo    "  end <lesson_num>             removes unused directories, displays"
    echo -e "                               stats and pushes to git.\n"

    echo    "  end-last                     same as end, but automatically"
    echo -e "                               calculates <lesson_num>.\n"

    echo -e "  help                         displays a help message.\n"

    echo    "Examples:"
    echo    "  lesson start 1"
    echo    "  lesson start-next"
    echo    "  lesson end 1"
    echo -e "  lesson end-last\n"

    echo    "Author:"
    echo -e "  Artyom Daniov\n"
}

# ------------------------------------------------------------------- #
#                          Global variables                           #
# ------------------------------------------------------------------- #

SHORT_OPTS="fhm:"
LONG_OPTS="force,help,make:"
HELP_MSG="Try: 'lesson -h | --help' for more information"
MAKEFILE_NAME="Makefile"
TIME_STAMP=".lesson_start"
LANGUAGE=""

LESSONS_DIR="Lessons"
LESSON_DIRS=(examples exercises theory whiteboard programs
                    homework todo ideas modules)

declare -A FLAGS=(
    [force]=0  # -f, --force
    [make]=""  # -m, --make
)

declare -A COMMANDS=(
    [start]=0       # lesson start <lesson_num>
    [start-next]=0
    [end]=0         # lesson end <lesson_num>
    [end-next]=0
)

# ------------------------------------------------------------------- #
#                     Global variables - start                        #
# ------------------------------------------------------------------- #

MAX_LESSON_NUM=100

# ------------------------------------------------------------------- #
#                       Global variables - end                        #
# ------------------------------------------------------------------- #

STYLE_ERRORS=0
EXERCISES_COMPLETED=0
PROGRAMS_WRITTEN=0

HOURS_=0
MINUTES_=0
SECONDS_=0

MIN_COMMIT_MESSAGE_LENGTH=20

# ------------------------------------------------------------------- #
#                           Functions                                 #
# ------------------------------------------------------------------- #

# Returns 0 if $1 is a script command
is_command()
{
    for com in "${!COMMANDS[@]}"; do
        [[ "$com" == "$1" ]] && return 0
    done
    return 1
}

# Returns 0 if $1 has a '.something' at the end
has_ext() { return $( [[ "$1" =~ ^.+\..+$ ]] ); }

# Calculates the lesson number based on $1 command (start | end)
calculate_lesson_number()
{
    local command=$1  # start | end

    case $command in
        start)
            lesson_num=$(ls | grep -E '[0-9]+' | sort -n | tail -1)
            lesson_num=$(( lesson_num + 1))
            echo $lesson_num  ;;
        end)
            lesson_num=$(ls | grep -E '[0-9]+' | sort -n | tail -1)
            echo $lesson_num  ;;
    esac
}

# Counts number of files with c, cpp and py extensions.
# Returns the language (c, cpp, python) with highest count.
detect_language()
{
    local lesson_num=$1
    local c=0
    local cpp=0
    local py=0

    for file in $(find $lesson_num -type f \( ! -iname $MAKEFILE_NAME \) -printf "%f\n"); do
        local extension=${file##*.}
        case $extension in
            c)
                c=$(( c + 1 ))     ;;
            cpp)
                cpp=$(( cpp + 1 )) ;;
            py)
                py=$(( py + 1 ))   ;;
        esac
    done

    if [[ $c -gt $cpp && $c -gt $py ]]; then
        echo c
    elif [[ $cpp -gt $c && $cpp -gt $py ]]; then
        echo cpp
    elif [[ $py -gt $c && $py -gt $cpp ]]; then
        echo python
    else
        echo ""
    fi
}

# Just for a nice printing to start and end screens.
print_language()
{
    local language=$1
    case $1 in
        c)
            echo C      ;;
        cpp)
            echo C++    ;;
        python)
            echo Python ;;
    esac
}

# ------------------------------------------------------------------- #
#                           Functions - start                         #
# ------------------------------------------------------------------- #

# Creates each of LESSON_DIRS directories.
create_lesson_directories()
{
    local lesson_num=$1

    for dir in "${LESSON_DIRS[@]}"; do
        mkdir -p "$lesson_num/$dir"
    done
}

# In eacn of the LESSON_DIRS creates a Makefile
create_makefiles()
{
    local lesson_num=$1

    for dir in "${LESSON_DIRS[@]}"; do
        new --make=${FLAGS[make]}
        mv "$MAKEFILE_NAME" "$lesson_num/$dir/$MAKEFILE_NAME"
    done
}

print_start_screen()
{
    local columns=$(tput cols)

    printf "%0.s-" $(seq 1 "$columns")  # upper border
    echo -e "\n"
    echoc "Welcome to Lesson #$LESSON_NUM, $(whoami)!\n"
    [[ -n $LANGUAGE ]] && echoc "Language: $(print_language $LANGUAGE)\n"
    echoc "Remember to express your ideas:\n"
    echoc " 1. Correctly\n"
    echoc " 2. Simply\n"
    echoc " 3. Efficiently\n"
    printf "%0.s-" $(seq 1 "$columns")  # lower border
}

# ------------------------------------------------------------------- #
#                           Functions - end                           #
# ------------------------------------------------------------------- #

# Increases STYLE_ERRORS and prints an error message
# if $1 file doesn't have an extension.
check_extension()
{
    local file=$1

    if ! has_ext "$file" && [[ $file != "$MAKEFILE_NAME" ]]; then
        STYLE_ERRORS=$(( STYLE_ERRORS + 1 ))
        echo "Style Error: '$file' doesn't have an extension." >&2
        echo "Fix: add an extension." >&2
    fi
}

# Increases STYLE_ERRORS and prints an error message if $1 file is empty.
check_emptiness()
{
    local file=$1
    if [[ ! -s $file ]]; then
        STYLE_ERRORS=$(( STYLE_ERRORS + 1 ))
        echo "Style Error: '$file' is empty." >&2
        echo "Fix: remove it." >&2
    fi
}

# If $1 dir is empty or only has a makefile -> remove it.
remove_empty_directory()
{
    local dir=$1

    if isempty "$dir" ||
        [[ -f $dir/$MAKEFILE_NAME && $(filenum "$dir") -eq 1 ]]; then
        rm -r "$dir"
    fi
}

# Increases EXERCISES_COMPLETED | PROGRAMS_WRITTEN depending on $1 mode
# if $2 file type is c, c++ or python
collect_file_stats()
{
    local mode=$1  # exercises | programs
    local file=$2
    local types=("C source" "C++ source" "Python script")

    for type_ in "${types[@]}"; do
        if [[ "$(file "$file")" =~ "$type_" ]]; then
            case $mode in
                exercises)
                    EXERCISES_COMPLETED=$(( EXERCISES_COMPLETED + 1 )) ;;
                programs)
                    PROGRAMS_WRITTEN=$(( PROGRAMS_WRITTEN + 1 ))       ;;
            esac
        fi
    done
}

collect_time_stats()
{
    local lesson_num=$1

    if [[ -f $lesson_num/$TIME_STAMP ]]; then
        local duration=$(( $(date +%s) - $(stat -c "%Y" "$lesson_num/$TIME_STAMP") ))
        HOURS_=$(( duration / 3600 ))
        MINUTES_=$(( duration / 60 - HOURS_ * 60))
        SECONDS_=$(( duration % 60 ))
        rm "$lesson_num/$TIME_STAMP"  # Delete a time-stamp file
    fi
}

# Tackle wrong login/password issues
git_push()
{
    while true; do
        git push && break
        echo ""
    done
}

# Tackle 'bad' commit messages
git_commit()
{
    while true; do
        read -rep "Enter commit message: " message

        if [[ ${#message} -lt $MIN_COMMIT_MESSAGE_LENGTH ]]; then
            echo "Error: commit message must be at least" \
                 "$MIN_COMMIT_MESSAGE_LENGTH characters long" >&2
            continue
        fi

        break
    done

    echo ""
    git commit -m "$message"
    echo ""
}

print_end_screen()
{
    local columns=$(tput cols)

    printf "%0.s-" $(seq 1 "$columns")
    echo -e "\n"
    echoc "End of lesson #$LESSON_NUM. Goodbye, $(whoami)!\n"
    [[ -n $LANGUAGE ]] && echoc "Language: $(print_language $LANGUAGE)\n"
    echoc "Stats:\n"
    echoc " 1. Lesson took $HOURS_:$MINUTES_:$SECONDS_\n"
    echoc " 2. Exercises completed: $EXERCISES_COMPLETED\n"
    echoc " 3. Programs written: $PROGRAMS_WRITTEN\n"
    printf "%0.s-" $(seq 1 "$columns")
}

# ------------------------------------------------------------------- #
#                           Parse options                             #
# ------------------------------------------------------------------- #

ARGV=$(getopt -o $SHORT_OPTS -l $LONG_OPTS -- "$@")

if [[ $? -ne 0 ]]; then
    echo "$HELP_MSG" >&2
    exit 1
fi

eval set -- "$ARGV"

# ------------------------------------------------------------------- #
#                           Toggle options                            #
# ------------------------------------------------------------------- #

while true; do
    case $1 in
        -f | --force)
            FLAGS[force]=1    ;;
        -h | --help)
            usage
            exit 0            ;;
        -m | --make)  # BAD !!!
            shift
            if [[ $1 == "c" || $1 == "cpp" ]]; then
                FLAGS[make]=$1
            elif is_command "$1"; then
                echo "Error: '-m, --make' option requires an argument." >&2
                echo "$HELP_MSG" >&2
                exit 1
            else
                echo "Error: '$1' makefile is not supported." >&2
                echo "Supported makefiles: c, cpp" >&2
                echo "$HELP_MSG" >&2
                exit 1
            fi
                            ;;
        --)
            shift
            break           ;;
    esac
    shift
done

# ------------------------------------------------------------------- #
#                           Validation                                #
# ------------------------------------------------------------------- #

# Check the <command> is given
if [[ $# -eq 0 ]]; then
    echo "Error: missing <command> argument" >&2
    echo "$HELP_MSG" >&2
    exit 1
fi

# ------------------------------------------------------------------- #
#                         Toggle command                              #
# ------------------------------------------------------------------- #

COMMAND=$1; shift

case $COMMAND in

    start)
        if [[ $# -eq 0 ]]; then
            echo "Error: '$COMMAND' missing <lesson_num> argument" >&2
            echo "$HELP_MSG" >&2
            exit 1
        fi
        FLAGS[start]=1           ;;

    start-next | start-next)
        FLAGS[start-next]=1      ;;

    end)
        if [[ $# -eq 0 ]]; then
            echo "Error: '$command' missing <lesson_num> argument" >&2
            echo "$HELP_MSG" >&2
            exit 1
        fi
        FLAGS[end]=1             ;;

    end-last | finish-last)
        FLAGS[end-last]=1        ;;

    help)
        usage
        exit 0                   ;;

    *)
        echo "Error: unknown command '$1'" >&2
        echo "$HELP_MSG" >&2
        exit 1                   ;;
esac

# ------------------------------------------------------------------- #
#                           Validation                                #
# ------------------------------------------------------------------- #

# Check if inside of LESSONS_DIR directory
if [[ ! "$(pwd)" =~ .+/$LESSONS_DIR$ ]]; then
    if [[ ${FLAGS[force]} -ne 1 ]]; then
        echo "Warning: Not inside '$LESSONS_DIR' directory"
        echo "It may affect how I work"
        read -rep "Proceed? [y/n]: " ans
        [[ ! "$ans" =~ ^[yY]$ ]] && exit 0
    fi
fi

# ------------------------------------------------------------------- #
#                       start-next | end-last                         #
# ------------------------------------------------------------------- #


if [[ ${FLAGS[start-next]} -eq 1 ]]; then

    LESSON_NUM=$(calculate_lesson_number "start")

    # ----------------------------------------------------------- #
    #                         Validation                          #
    # ----------------------------------------------------------- #

    # If we have a previous lesson
    if [[ $LESSON_NUM -gt 1 ]]; then

        LANGUAGE=$(detect_language $(( LESSON_NUM - 1 )))

        # If previous lesson had a makefile
        if [[ -n $(find $(( LESSON_NUM - 1 )) -type f -name $MAKEFILE_NAME) ]]; then
            FLAGS[make]=$LANGUAGE
        fi
    fi

    FLAGS[start]=1

elif [[ ${FLAGS[end-last]} -eq 1 ]]; then

    LESSON_NUM=$(calculate_lesson_number "end")

    # ----------------------------------------------------------- #
    #                         Validation                          #
    # ----------------------------------------------------------- #

    # If running end-last command on an empty directory.
    if [[ -z $LESSON_NUM ]]; then
        echo "Error: no previous lesson found." >&2
        echo "Fix: try 'lesson start-next'." >&2
        exit 1
    fi

    LANGUAGE=$(detect_language $LESSON_NUM)
    FLAGS[end]=1

elif [[ ${FLAGS[start]} -eq 1 ]]; then
    LESSON_NUM=${1##*/}  # remove parent directory names
    if [[ $LESSON_NUM -gt 1 ]]; then
        LANGUAGE=$(detect_language $(( LESSON_NUM - 1 )))
    fi

elif [[ ${FLAGS[end]} -eq 1 ]]; then
    LESSON_NUM=${1##*/}  # remove parent directory names
    LANGUAGE=$(detect_language $LESSON_NUM)
fi

shift

# ------------------------------------------------------------------- #
#                           Validation                                #
# ------------------------------------------------------------------- #

# Check if <lesson_num> argument is a positive number
if [[ ! "$LESSON_NUM" =~ ^[0-9]+$ ]]; then
    echo "Error: <lesson_num> argument must be an integer" >&2
    echo "Fix: Try 1..$MAX_LESSON_NUM" >&2
    exit 1
fi

# Check if <lesson_num> argument is less than or equal MAX_LESSON_NUM
if [[ ! "$LESSON_NUM" -le $MAX_LESSON_NUM ]]; then
    if [[ ${FLAGS[force]} -ne 1 ]]; then
        echo "Warning: $LESSON_NUM exceeds the MAX_LESSON_NUM"
        echo "It may affect how I work"
        read -rep "Proceed? [y/n]: " ans
        [[ ! "$ans" =~ ^[yY]$ ]] && exit 0
    fi
fi

# ------------------------------------------------------------------- #
#                             start                                   #
# ------------------------------------------------------------------- #

if [[ ${FLAGS[start]} -eq 1 ]]; then

    # ----------------------------------------------------------- #
    #                         Validation                          #
    # ----------------------------------------------------------- #

    # Check if there is a Lesson with number <lesson_num>
    if [[ -d $LESSON_NUM ]]; then
        echo "Error: Lesson number '$LESSON_NUM' already exists" >&2
        echo "Fix: Try another number" >&2
        exit 1
    fi

    create_lesson_directories "$LESSON_NUM"

    # If '-m, --make' is on
    if [[ -n ${FLAGS[make]} ]]; then

        # --------------------------------------------------- #
        #                       Validation                    #
        # --------------------------------------------------- #

        # Check that 'new' script is installed
        if [[ ! -x $(command -v new) ]]; then
            echo "Error: 'new' command not found" >&2
            echo "Fix: run the 'install' script" >&2
            exit 1
        fi

        create_makefiles "$LESSON_NUM"  # In each lesson directory
    fi

    touch "$LESSON_NUM/$TIME_STAMP"  # Create a time-stamp file

    print_start_screen

# ------------------------------------------------------------------- #
#                               end                                   #
# ------------------------------------------------------------------- #

elif [[ ${FLAGS[end]} -eq 1 ]]; then

    # ----------------------------------------------------------- #
    #                         Validation                          #
    # ----------------------------------------------------------- #

    # Check if there is no lesson with number <lesson_num>
    if [[ ! -d $LESSON_NUM ]]; then
        echo "Error: Lesson number '$LESSON_NUM' doesn't exist" >&2
        exit 1
    fi

    ## ANALYZE EACH DIRECTORY

    for dir in "${LESSON_DIRS[@]}"; do  # for each directory
        full_dir="$LESSON_NUM/$dir"

        if [[ -d $full_dir ]]; then  # if directory exists

            for file in $(ls "$full_dir"); do  # for each file in directory
                full_file="$LESSON_NUM/$dir/$file"

                if [[ "$file" != "$MAKEFILE_NAME" ]]; then
                    check_extension "$full_file"
                    check_emptiness "$full_file"
                fi

                case $dir in
                    exercises | programs)
                        collect_file_stats "$dir" "$full_file" ;;
                esac
            done

            remove_empty_directory "$full_dir" # empty or only has a makefile
        fi

    done

    [[ $STYLE_ERRORS -gt 0 ]] && exit 1 # Exit if have 'style' errors

    collect_time_stats "$LESSON_NUM"

    # If git repo and changes were made
    if [[ -d ".git" && -n $(git status --porcelain) ]]; then
        git status; echo ""
        git add .
        git_commit
        git_push
    fi

    print_end_screen

    if isempty "$LESSON_NUM"; then
        rmdir "$LESSON_NUM"
    else
        tree "$LESSON_NUM"
    fi

fi

exit 0

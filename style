#!/bin/bash

BASH_LIB=$HOME/.bash_lib

# style

# var

VAR_FLAG=0
VAR_MIN_LENGTH=3

# macro

# TODO
# Report line number and position of macro
# better check macros, '-' is not catched

MACRO_FLAG=0

# comment

# TODO
# Make it more intelligent, suggesting how the comment should look
# For now only recognizes a comment that has a 'space/*space' on the first line

COMMENT_FLAG=0
HEAD_LINES=1

# How to use this script
usage() {
	echo "Reports style errors in c-source files."
	echo ""
	echo "Usage:"
	echo "  style <command> [options] <c_source_file> [c_source_file...]"
	echo ""
	echo "Commands:"
	echo "  var        checks that variables are written in lower_snake_case"
	echo "             and are at least $VAR_MIN_LENGTH characters long"
	echo "  macro      checks that macros are written in UPPER_SNAKE_CASE"
	echo "  comment    checks for a multiline comment at the top"
	echo ""
	echo "Dependencies:"
	echo "  bash_lib"
}

# Import code from $BASH_LIB file
if [[ -f $BASH_LIB ]]; then
	. $BASH_LIB
else
	echo "Unable to find '$BASH_LIB' file."
	echo "Download at https://github.com/defytheflow/dotfiles.git and run again."
	exit 1
fi

# Check 'style' options (Those that appear before the first command)
if [[ $# -gt 0 ]]; then
	# While current argument starts with -,-- look for the option
	while [[ "$1" =~ ^-[-]?[a-zA-Z]+$ ]]; do
		case $1 in
			-h | --help )
				usage
				exit 0
				;;
			* )
				fatal_error "Unknown option $(reversed $1)"
				;;
		esac
	done
fi

# Remove all options to check number of required arguments
ARGS=($@)
ARGS=( ${ARGS[@]/-*/} )

# Expected at least two arguments <command> and <c_source_file>
if [[ ${#ARGS[@]} -eq 1 ]]; then
	usage
	echo ""
	fatal_error "Missing <c_source_file> argument"
elif [[ $# -eq 0 ]]; then
	usage
	echo ""
	fatal_error "Missing <command> <c_source_file> arguments"
fi

# Check the command argument. It must be the 1 of ARGS
case ${ARGS[0]} in
	var )
		VAR_FLAG=1
		;;
	macro )
		MACRO_FLAG=1
		;;
	comment )
		COMMENT_FLAG=1
		;;
	* )
		fatal_error "Unknown command $(reversed ${ARGS[0]})"
esac

# macro command
do_macro() {
	# Collect all the '#define MACRO' into $defines array
	defines=($(cat $1 | grep -oh -P "^#define [a-zA-Z0-9_]+ +"))

	# defines = ["#define", "MACRO1", "#define", "MACRO2"]

	# Remove all the '#define' from array leaving only $macros
	macros=( ${defines[@]/"#define"/} )

	# macros = ["MACRO1", "MACRO2"]

	# Report style erros on macros
	for macro in ${macros[@]}; do
		if [[ ! "$macro" =~ ^[A-Z0-9_]+$ ]]; then
			error "$(reversed $1). Bad style macro - $(reversed $macro)"
		fi
	done
}

# comment command
do_comment() {
	# Check that '  /*  ' appears on the first $HEAD_LINES of the file
	if [[ ! "$(head -$HEAD_LINES $1)" =~ ^[[:space:]]*/\*[[:space:]]*$ ]]; then
		error "No comment found at the top of $(reversed $1) file"
	fi
}

# Iterate over <c_source_file> arguments
ARGC=$#
ARGV=("$@")
for (( i = 1; i < ARGC; ++i )); do

	c_source=${ARGV[i]}
	
	# Check if c_source ends with '.c'
	if [[ ! "$c_source" =~ .+\.c$ ]]; then
		error "$(reversed $c_source) must end with '.c'"
		continue
	fi

	# Check if c_source exists
	if [[ ! -f $c_source ]]; then
		error "File $(reversed $c_source) doesn't exist"
		continue
	fi

	# Check if c_source is indeed c-source code
	if [[ ! "$(file $c_source)" =~ ^.+C[[:space:]]source.+$ ]]; then
		error "$(reversed $c_source) is not a c-source file"
		continue
	fi

	if [[ $VAR_FLAG == 1 ]]; then
		echo "do var"
	elif [[ $MACRO_FLAG == 1 ]]; then
		do_macro $c_source
	elif [[ $COMMENT_FLAG == 1 ]]; then
		do_comment $c_source
	fi

done

exit 0
